= \REXML入門

== なぜ\REXMLなのか

- Rubyの\REXMLライブラリはRubyの配布物の一部です。
  そのためgemのインストールは必要ありません。
- \REXMLは手厚く維持管理されています。
- \REXMLは成熟しており、長年使われてきました。

== インクルードすべきや否や

REXMLはモジュールです。使うためにはrequireせねばなりません。

  require 'rexml' # => true

また、includeしなければREXMLを参照するのに完全な修飾を付けねばなりません。

  REXML::Document # => REXML::Document

ここからモジュールをincludeすれば、お好みで<tt>REXML::</tt>を省くことができます。

  include REXML
  Document # => REXML::Document
  REXML::Document # => REXML::Document

== 事前に必要なもの

ここにある全ての例では以下のコードが実行されていることを前提にしています。

  require 'rexml'
  include REXML

ここにある多くのソースのXMLの例はw3schools.comにある{books.xml}[https://www.w3schools.com/xml/books.xml]が元になっています。そちらのページを新しいタブで開いておく（ブラウザによってはCtrl-クリック）と便利かもしれません。

なお、ブラウザはXMLの空白を変更しXMLの宣言がないものを表示するかもしれません。このような場合がそうです。

  <?xml version="1.0" encoding="UTF-8"?>

便宜上XMLを文字列変数に保存しておきます。

  require 'open-uri'
  source_string = URI.open('https://www.w3schools.com/xml/books.xml').read

またファイルにも保存しておきます。

  File.write('source_file.xml', source_string)

ここにある例では全て、変数+doc+にはこれらのソースから派生した文書のみが入っています。

  doc = Document.new(source_string)

== \XMLのソースを解析する

=== 文書を解析する

XMLのソースの解析には REXML::Document::new メソッドを使います。

ソースには文字列が使えます。

  doc = Document.new(source_string)

もしくはIOストリームも使えます。

  doc = File.open('source_file.xml', 'r') do |io|
    Document.new(io)
  end

メソッド<tt>URI.open</tt>はStringIOオブジェクトを返すので、ソースはwebページからとすることもできます。

  require 'open-uri'
  io = URI.open("https://www.w3schools.com/xml/books.xml")
  io.class # => StringIO
  doc = Document.new(io)

こうしたソースが何であれ、返されるオブジェクトは REXML::Document です。

  doc       # => <UNDEFINED> ... </>
  doc.class # => REXML::Document

補足：<tt>'UNDEFINED'</tt>は文書について表示される「名前」です。
<tt>doc.name</tt>が空の文字列<tt>""</tt>を返す場合でも同じことです。

解析された文書は多様なクラスの\REXMLオブジェクトを生成しますが、特に注目すべきは恐らく REXML::Document と
REXML::Element の2つでしょう。
これら2つのクラスはこの入門でかなり詳しく押さえます。

=== 文脈（解析オプション）

文書を解析する文脈は、XMLが読まれたり保管されたりする方法に影響を与えるハッシュです。

文脈の各項目は次の通り。

- +:respect_whitespace+: 空白の扱いを制御します。
- +:compress_whitespace+: 空白が圧縮されるかどうかを決めます。
- +:ignore_whitespace_nodes+: 空白のみのノードが無視されるかを決めます。
- +:raw+: 特殊文字と実体の扱いを制御します。

{要素の文脈}[../context_rdoc.html]を参照してください。

== 文書を探索する

REXML::DocumentオブジェクトはXML文書を表現します。

オブジェクトはその先祖のクラスから継承します。

- REXML::Child（モジュール REXML::Node がインクルードされています）
  - REXML::Parent（{Enumerable}[rdoc-ref:Enumerable]モジュールがインクルードされています）
    - REXML::Element（モジュール REXML::Namespace がインクルードされています）
      - REXML::Document

この節ではこれらのプロパティとメソッドのうち文書に特有なもののみを押さえます（つまり、継承したりインクルードされたりしたものは除きます）。

=== 文書のプロパティ

文書には（子要素の他に）いくつかのプロパティがあります。

- 文書種別
- ノードの種類
- 名前
- 文書
- XPath

[文書種別]

  文書は文書種別を持つことがあります。

    my_xml = '<!DOCTYPE foo>'
    my_doc = Document.new(my_xml)
    doc_type = my_doc.doctype
    doc_type.class # => REXML::DocType
    doc_type.to_s  # => "<!DOCTYPE foo>"

[ノードの種類]

  文書はノードの種類も持ちます（常に+:document+です）。

    doc.node_type # => :document

[名前]

  文書は名前を持ちます（常に空文字列です）。

    doc.name # => ""

[文書]

  メソッド REXML::Document#document は+self+を返します。

    doc.document == doc # => true

  それぞれのクラス（\REXML::Elementや\REXML::Child）のオブジェクトは文書を持つかもしれません。
  これはオブジェクトが属する文書です。
  もしそのような文書があれば、その文書は\REXML::Documentオブジェクトです。

    doc.root.document.class # => REXML::Document

[XPath]

  メソッド REXML::Element#xpath は要素へのxpath文字列を返します。
  最も距離の離れた先祖からの相対的なものです。

    doc.root.class             # => REXML::Element
    doc.root.xpath             # => "/bookstore"
    doc.root.texts.first       # => "\n\n"
    doc.root.texts.first.xpath # => "/bookstore/text()"

  先祖がいなければ要素の展開された名前を返します。

    Element.new('foo').xpath # => "foo"

=== 文書の子

文書にはこれらの種類の子を持ち得ます。

- XML宣言
- ルート要素
- テキスト
- 処理手続き
- コメント
- CDATA

[XML宣言]

  文書にはXML宣言があることがあります。
  この宣言は REXML::XMLDecl オブジェクトとして格納されます。

    doc.xml_decl       # => <?xml ... ?>
    doc.xml_decl.class # => REXML::XMLDecl

    Document.new('').xml_decl # => <?xml ... ?>

    my_xml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>"'
    my_doc = Document.new(my_xml)
    xml_decl = my_doc.xml_decl
    xml_decl.to_s  # => "<?xml version='1.0' encoding='UTF-8' standalone="yes"?>"

  バージョン、エンコーディング、独立したものかどうかの値は個別に取得できます。

    my_doc.version      # => "1.0"
    my_doc.encoding     # => "UTF-8"
    my_doc.stand_alone? # => "yes"

[ルート要素]

  文書は*ルート要素*と呼ばれる単一の子要素を持ち得ます。
  この要素は REXML::Element オブジェクトとして格納され、メソッド+root+で取得できます。

    doc.root           # => <bookstore> ... </>
    doc.root.class     # => REXML::Element

    Document.new('').root # => nil

[テキスト]

文書にはテキストの集まりを持つことがあり、それぞれは REXML::Text オブジェクトとして保管されます。

    doc.texts.each {|t| p [t.class, t] }

  出力：

    [REXML::Text, "\n"]

[処理手続き]

  文書は処理手続きを持つことがあり、 REXML::Instruction オブジェクトとして保管されます。



  出力：

    [REXML::Instruction, <?p-i my-application ...?>]
    [REXML::Instruction, <?p-i my-application ...?>]

[コメント]

  文書にはコメントがあることがあり、 REXML::Comment オブジェクトとして保管されます。

    my_xml = <<-EOT
      <!--foo-->
      <!--bar-->
    EOT
    my_doc = Document.new(my_xml)
    my_doc.comments.each {|c| p [c.class, c] }

  出力：

    [REXML::Comment, #<REXML::Comment: @parent=<UNDEFINED> ... </>, @string="foo">]
    [REXML::Comment, #<REXML::Comment: @parent=<UNDEFINED> ... </>, @string="bar">]

[CDATA]

  文書にはCDATA項目があることがあり、 REXML::CData オブジェクトを保管します。

    my_xml = <<-EOT
      <![CDATA[foo]]>
      <![CDATA[bar]]>
    EOT
    my_doc = Document.new(my_xml)
    my_doc.cdatas.each {|cd| p [cd.class, cd] }

  出力：

    [REXML::CData, "foo"]
    [REXML::CData, "bar"]

文書の内容物はノードからなる木であり、ルート要素から枝分かれします。

  doc.root.children.each do |child|
    p [child, child.class]
  end

出力：

  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='cooking'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='children'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web' cover='paperback'> ... </>]
  [REXML::Text, "\n\n"]

== 要素を探索する

REXML::ElementオブジェクトはXML要素を表現します。

オブジェクトはその先祖のクラスから継承します。

- REXML::Child（モジュール REXML::Node がインクルードされています）
  - REXML::Parent（{Enumerable}[rdoc-ref:Enumerable]モジュールがインクルードされています）
    - REXML::Element（モジュール REXML::Namespace がインクルードされています）

この節は以下のメソッドを押さえます。

- REXML::Element 自体に定義されています。
- REXML::Parent と REXML::Child から継承されています。
- REXML::Node をインクルードしています。

=== 要素の中身

[短い文字列表現]

  REXML::Element#inspect を使うと短い文字列表現が取得されます。

    doc.root.inspect # => "<bookstore> ... </>"

  点々 (<tt>...</tt>) は要素が子を持つことを示します。
  子がなければ点々は省かれます。

    Element.new('foo').inspect # => "<foo/>"

  要素に属性があれば、その属性も含まれます。

    doc.root.elements.first.inspect # => "<book category='cooking'> ... </>"

[拡張された文字列表現]

  継承されたメソッド REXML::Child.bytes を使うと拡張された文字列表現が取得されます。

    doc.root.bytes # => "<bookstore>\n\n<book category='cooking'>\n  <title lang='en'>Everyday Italian</title>\n  <author>Giada De Laurentiis</author>\n  <year>2005</year>\n  <price>30.00</price>\n</book>\n\n<book category='children'>\n  <title lang='en'>Harry Potter</title>\n  <author>J K. Rowling</author>\n  <year>2005</year>\n  <price>29.99</price>\n</book>\n\n<book category='web'>\n  <title lang='en'>XQuery Kick Start</title>\n  <author>James McGovern</author>\n  <author>Per Bothner</author>\n  <author>Kurt Cagle</author>\n  <author>James Linn</author>\n  <author>Vaidyanathan Nagarajan</author>\n  <year>2003</year>\n  <price>49.99</price>\n</book>\n\n<book category='web' cover='paperback'>\n  <title lang='en'>Learning XML</title>\n  <author>Erik T. Ray</author>\n  <year>2003</year>\n  <price>39.95</price>\n</book>\n\n</bookstore>"

[ノードの種類]

  REXML::Element#node_typeメソッドを使うとノードの種類が取得されます（常に+:element+です）。

    doc.root.node_type # => :element

[生モード]

  REXML::Element#rawメソッドを使うと生モードが設定されているかどうか（+true+または+nil+）が取得されます。

    doc.root.raw # => nil

[文脈]

  REXML::Element#contextメソッドを使うと文脈ハッシュが取得されます（{要素の文脈}[../context_rdoc.html]を参照してください）。

    doc.root.context # => {}

=== 関係

要素には以下があることがあります。

- 先祖
- 兄弟
- 子

==== 先祖

[その要素を含む文書]

  REXML::Element#documentメソッドを使うと、もしあれば、その要素を含む文書が取得されます。

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.document                    # => <UNDEFINED> ... </>
    ele = Element.new('foo')        # => <foo/>
    ele.document                    # => nil

[ルート要素]

  REXML::Element#rootメソッドを使うと根要素が取得されます。

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.root                        # => <bookstore> ... </>
    ele = Element.new('foo')        # => <foo/>
    ele.root                        # => <foo/>

[根ノード]

  REXML::Element#root_node メソッドを使うと最も離れた先祖が取得されます。
  先祖は、もしあればその要素を含む文書で、なければ根要素です。

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.root_node                   # => <UNDEFINED> ... </>
    ele = Element.new('foo')        # => <foo/>
    ele.root_node                   # => <foo/>

[親]

  継承されたメソッド REXML::Child#parent を使うと親が取得されます。

    ele = doc.root                # => <bookstore> ... </>
    ele.parent                    # => <UNDEFINED> ... </>
    ele = doc.root.elements.first # => <book category='cooking'> ... </>
    ele.parent                    # => <bookstore> ... </>

  インクルードされたメソッド REXML::Node#index_in_parent を使うと、（要素の子だけでなく）その要素の親の全ての子のうちその要素のインデックスが取得されます。
  なお<tt>doc.root.elements[n]</tt>のインデックスは1起点ですが、返却されるインデックスは0起点です。

    doc.root.children # =>
      # ["\n\n",
      #  <book category='cooking'> ... </>,
      #  "\n\n",
      #  <book category='children'> ... </>,
      #  "\n\n",
      #  <book category='web'> ... </>,
      #  "\n\n",
      #  <book category='web' cover='paperback'> ... </>,
      #  "\n\n"]
    ele = doc.root.elements[1] # => <book category='cooking'> ... </>
    ele.index_in_parent # => 2
    ele = doc.root.elements[2]  # => <book category='children'> ... </>
    ele.index_in_parent# => 4

==== 兄弟

[次の要素]

  メソッド REXML::Element#next_element を使うと後続する最初の兄弟が取得されます。
  兄弟があるならそれは要素です（なければ+nil+です）。

    ele = doc.root.elements[1]
    while ele do
      p [ele.class, ele]
      ele = ele.next_element
    end
    p ele

  出力：

    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]

[前の要素]

  メソッド REXML::Element#previous_element を使うと先行する最初の兄弟が取得されます。
  兄弟があるならそれは要素です（なければ+nil+です）。

    ele = doc.root.elements[4]
    while ele do
      p [ele.class, ele]
      ele = ele.previous_element
    end
    p ele

  出力：

    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <book category='cooking'> ... </>]

[次のノード]

  インクルードされるメソッド REXML::Node.next_sibling_node （またはその別称の<tt>next_sibling</tt>）を使うと、そのクラスによらず後続する最初のノードが取得されます。

    node = doc.root.children[0]
    while node do
      p [node.class, node]
      node = node.next_sibling
    end
    p node

  出力：

    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Text, "\n\n"]

[前のノード]

  インクルードされるメソッド REXML::Node.previous_sibling_node （もしくはその別称<tt>previous_sibling</tt>）を使うと、クラスによらず先行する最初のノードが取得されます。

    node = doc.root.children[-1]
    while node do
      p [node.class, node]
      node = node.previous_sibling
    end
    p node

  出力：

    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Text, "\n\n"]

==== 子

[子の個数]

  継承されたメソッド REXML::Parent.size を使うとその要素中の（全種類の）ノードの個数が取得されます。

    doc.root.size # => 9

[子ノード]

  継承されたメソッド REXML::Parent.children を使うと（全種類の）子ノードの配列が取得されます。

    doc.root.children # =>
                      # ["\n\n",
                      #  <book category='cooking'> ... </>,
                      #  "\n\n",
                      #  <book category='children'> ... </>,
                      #  "\n\n",
                      #  <book category='web'> ... </>,
                      #  "\n\n",
                      #  <book category='web' cover='paperback'> ... </>,
                      #  "\n\n"]

[インデックスにある子]

  メソッド REXML::Element#[] を使うと、与えられた数値のインデックスに子があればそれを、そのような子がなければ+nil+が取得されます。

    doc.root[0]  # => "\n\n"
    doc.root[1]  # => <book category='cooking'> ... </>
    doc.root[7]  # => <book category='web' cover='paperback'> ... </>
    doc.root[8]  # => "\n\n"

    doc.root[-1] # => "\n\n"
    doc.root[-2] # => <book category='web' cover='paperback'> ... </>

    doc.root[50] # => nil

[子のインデックス]

  メソッド REXML::Parent#index を使うと、もしあれば与えられたオブジェクトのゼロ起点の子のインデックスが、そのような子がなければ<tt>#size - 1</tt>が取得されます。

    ele = doc.root     # => <bookstore> ... </>
    ele.index(ele[0])  # => 0
    ele.index(ele[1])  # => 1
    ele.index(ele[7])  # => 7
    ele.index(ele[8])  # => 8

    ele.index(ele[-1]) # => 8
    ele.index(ele[-2]) # => 7

    ele.index(ele[50]) # => 8

[要素の子]

  メソッド REXML::Element#has_elements? を使うと要素に要素の子があるかどうかが取得されます。

    doc.root.has_elements?                  # => true
    REXML::Element.new('foo').has_elements? # => false

  メソッド REXML::Element#elements を使うと、その要素の子を含む REXML::Elements オブジェクトが取得されます。

    eles = doc.root.elements
    eles      # => #<REXML::Elements:0x000001ee2848e960 @element=<bookstore> ... </>>
    eles.size # => 4
    eles.each {|e| p [e.class], e }

  出力：

    [<book category='cooking'> ... </>,
     <book category='children'> ... </>,
     <book category='web'> ... </>,
     <book category='web' cover='paperback'> ... </>
    ]

なおこの例ではルート要素の全ての子要素は<tt>'book'</tt>という同じ名前の要素になっていますが、全ての文書についてそうではありません。
根要素（あるいは他の任意の要素）は自由に混ざった子要素を持ちえます。

[子のCDATA]

  メソッド REXML::Element#cdatas を使うと子のCDATAの凍結された配列が取得されます。

    my_xml = <<-EOT
      <root>
        <![CDATA[foo]]>
        <![CDATA[bar]]>
      </root>
    EOT
    my_doc = REXML::Document.new(my_xml)
    cdatas my_doc.root.cdatas
    cdatas.frozen?              # => true
    cdatas.map {|cd| cd.class } # => [REXML::CData, REXML::CData]

[子のコメント]

  メソッド REXML::Element#comments を使うと子のコメントの凍結された配列が取得されます。

    my_xml = <<-EOT
      <root>
        <!--foo-->
        <!--bar-->
      </root>
    EOT
    my_doc = REXML::Document.new(my_xml)
    comments = my_doc.root.comments
    comments.frozen?            # => true
    comments.map {|c| c.class } # => [REXML::Comment, REXML::Comment]
    comments.map {|c| c.to_s }  # => ["foo", "bar"]

[子の処理手続き]

  メソッド REXML::Element#instructions を使うと子の処理手続きの凍結された配列が取得されます。

    my_xml = <<-EOT
      <root>
        <?target0 foo?>
        <?target1 bar?>
      </root>
    EOT
    my_doc = REXML::Document.new(my_xml)
    instrs = my_doc.root.instructions
    instrs.frozen?            # => true
    instrs.map {|i| i.class } # => [REXML::Instruction, REXML::Instruction]
    instrs.map {|i| i.to_s }  # => ["<?target0 foo?>", "<?target1 bar?>"]

[子のテキスト]

  メソッド REXML::Element#has_text? を使うと要素に子のテキストを持つかどうかが取得されます。

    doc.root.has_text?                  # => true
    REXML::Element.new('foo').has_text? # => false

  メソッド REXML::Element#texts を使うと子のテキストの凍結された配列が取得されます。

    my_xml = '<root><a/>text<b/>more<c/></root>'
    my_doc = REXML::Document.new(my_xml)
    texts = my_doc.root.texts
    texts.frozen?            # => true
    texts.map {|t| t.class } # => [REXML::Text, REXML::Text]
    texts.map {|t| t.to_s }  # => ["text", "more"]

[親]

  継承されたメソッド REXML::Parent.parent? を使うと要素が親かどうかが取得されます。
  REXML::Child#parent が+false+を返す他は常に+true+を返します。

     doc.root.parent? # => true

=== 要素の属性

メソッド REXML::Element#has_attributes? を使うと要素に属性があるかが返ります。

  ele = doc.root           # => <bookstore> ... </>
  ele.has_attributes?      # => false
  ele = ele.elements.first # => <book category='cooking'> ... </>
  ele.has_attributes?      # => true

メソッド REXML::Element#attributes を使うとその要素の属性を含むハッシュが返ります。
それぞれのハッシュのキーは文字列の属性名です。
それぞれのハッシュのバリューは REXML::Attribute オブジェクトです。

  ele = doc.root                  # => <bookstore> ... </>
  attrs = ele.attributes          # => {}

  ele = ele.elements.first        # => <book category='cooking'> ... </>
  attrs = ele.attributes          # => {"category"=>category='cooking'}
  attrs.size                      # => 1
  attr_name = attrs.keys.first    # => "category"
  attr_name.class                 # => String
  attr_value = attrs.values.first # => category='cooking'
  attr_value.class                # => REXML::Attribute

メソッド REXML::Element#[] を使うと与えられた属性の文字列値が取得されます。
属性は文字列ないしシンボルとして与えることができます。

  ele = doc.root.elements.first # => <book category='cooking'> ... </>
  attr_value = ele['category']  # => "cooking"
  attr_value.class              # => String
  ele['nosuch']                  # => nil

メソッド REXML::Element#attribute を使うと名前付き属性の値が取得されます。

  my_xml = "<root xmlns:a='a' a:x='a:x' x='x'/>"
  my_doc = REXML::Document.new(my_xml)
  my_doc.root.attribute("x")      # => x='x'
  my_doc.root.attribute("x", "a") # => a:x='a:x'

== 空白

メソッド REXML::Element#ignore_whitespace_nodes
を使うとXMLが構文解析されるときに空白のノードが無視されるかどうかが決められます。
もし無視されるなら+true+を、そうでなければ+nil+を返します。

メソッド REXML::Element#whitespace を使うとその要素で空白が認められているかどうかを見定めます。
もし認められているなら+true+を、そうでなければ+false+が返ります。

== 名前空間

メソッド REXML::Element#namespace を使うとその要素の名前空間URIの文字列が取得されます。
この名前空間はその先祖の名前空間から導出されることがあります。

  xml_string = <<-EOT
    <root>
       <a xmlns='1' xmlns:y='2'>
         <b/>
         <c xmlns:z='3'/>
       </a>
    </root>
  EOT
  d = Document.new(xml_string)
  b = d.elements['//b']
  b.namespace      # => "1"
  b.namespace('y') # => "2"
  b.namespace('nosuch') # => nil

メソッド REXML::Element#namespaces を使うとその要素とその先祖で定義された全ての名前空間のハッシュが取得されます。

  xml_string = <<-EOT
    <root>
       <a xmlns:x='1' xmlns:y='2'>
         <b/>
         <c xmlns:z='3'/>
       </a>
    </root>
  EOT
  d = Document.new(xml_string)
  d.elements['//a'].namespaces # => {"x"=>"1", "y"=>"2"}
  d.elements['//b'].namespaces # => {"x"=>"1", "y"=>"2"}
  d.elements['//c'].namespaces # => {"x"=>"1", "y"=>"2", "z"=>"3"}

メソッド REXML::Element#prefixes
を使うとその要素とその先祖で定義された全ての名前空間の文字列前置詞（名前）の配列が取得されます。

  xml_string = <<-EOT
    <root>
       <a xmlns:x='1' xmlns:y='2'>
         <b/>
         <c xmlns:z='3'/>
       </a>
    </root>
  EOT
  d = Document.new(xml_string, {compress_whitespace: :all})
  d.elements['//a'].prefixes # => ["x", "y"]
  d.elements['//b'].prefixes # => ["x", "y"]
  d.elements['//c'].prefixes # => ["x", "y", "z"]

== 巡回

特定のメソッドを使うと要素の子を巡回できます。
与えられた条件に合うそれぞれの子は与えられたブロックにyieldされます。

[全ての子を巡回する]

  継承されたメソッド REXML::Parent#each （またはその別称である #each_child ）を使うとその要素の全ての子を巡回します。

    doc.root.each {|child| p [child.class, child] }

  出力：

    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Text, "\n\n"]

[要素な子を巡回する]

  メソッド REXML::Element#each_element を使うとその要素の要素な子のみを巡回します。

    doc.root.each_element {|e| p [e.class, e] }

  出力：

    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]

[要素な子を属性付きで巡回する]

  メソッド REXML::Element#each_element_with_attribute を単一の引数+attr_name+を使うと、与えられた属性を持つ要素な子を順に巡回します。

    my_doc = Document.new '<a><b id="1"/><c id="2"/><d id="1"/><e/></a>'
    my_doc.root.each_element_with_attribute('id') {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b id='1'/>]
    [REXML::Element, <c id='2'/>]
    [REXML::Element, <d id='1'/>]

  2つ目の引数+value+付きで同じメソッドを使うと与えられた属性とバリューを持つ要素の子要素を順に巡回します。

    my_doc.root.each_element_with_attribute('id', '1') {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b id='1'/>]
    [REXML::Element, <d id='1'/>]

  3つ目の引数+max+付きで同じメソッドを使うと、与えられた数を越えない分の要素な子を巡回します。

    my_doc.root.each_element_with_attribute('id', '1', 1) {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b id='1'/>]

  4つ目の引数+xpath+付きで同じメソッドを使うと与えられたxpathに照合する要素な子のみを巡回します。

    my_doc.root.each_element_with_attribute('id', '1', 2, '//d') {|e| p [e.class, e] }

  出力：

    [REXML::Element, <d id='1'/>]

[テキスト付きの要素な子を巡回する]

  引数なしでメソッド REXML::Element#each_element_with_text を使うとテキストを持つ要素な子を巡回します。

    my_doc = Document.new '<a><b>b</b><c>b</c><d>d</d><e/></a>'
    my_doc.root.each_element_with_text {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b> ... </>]
    [REXML::Element, <c> ... </>]
    [REXML::Element, <d> ... </>]

  単一の引数+text+で同じメソッドを使うと厳密にそのテキストを持つ要素な子を巡回します。

    my_doc.root.each_element_with_text('b') {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b> ... </>]
    [REXML::Element, <c> ... </>]

  さらに2つ目の引数+max+付きで同じメソッドを使うと与えられた数を越えない要素な子を巡回します。

    my_doc.root.each_element_with_text('b', 1) {|e| p [e.class, e] }

  出力：

    [REXML::Element, <b> ... </>]

  さらに3つ目の引数+xpath+付きで同じメソッドを使うと、与えられたxpathにも照合する要素な子のみを巡回します。

    my_doc.root.each_element_with_text('b', 2, '//c') {|e| p [e.class, e] }

  出力：

    [REXML::Element, <c> ... </>]

[要素な子のインデックスを巡回する]

  継承されたメソッド REXML::Parent#each_index を使うと（要素の子のものだけではなく）全ての要素のインデックスを巡回します。

    doc.root.each_index {|i| print i }

  出力：

    012345678

[子を再帰的に巡回する]

  インクルードされたメソッド REXML::Node#each_recursive を使うと全ての子を再帰的に巡回します。

    doc.root.each_recursive {|child| p [child.class, child] }

  出力：

    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Element, <title lang='en'> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <year> ... </>]
    [REXML::Element, <price> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <title lang='en'> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <year> ... </>]
    [REXML::Element, <price> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <title lang='en'> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <year> ... </>]
    [REXML::Element, <price> ... </>]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Element, <title lang='en'> ... </>]
    [REXML::Element, <author> ... </>]
    [REXML::Element, <year> ... </>]
    [REXML::Element, <price> ... </>]

== 検索

要素の子孫から検索するメソッドがあり、使えます。

メソッド REXML::Element#get_elements を使い、与えられた+xpath+に照合する要素の全ての要素な子を取得できます。

  xml_string = <<-EOT
  <root>
    <a level='1'>
      <a level='2'/>
    </a>
  </root>
  EOT
  d = Document.new(xml_string)
  d.root.get_elements('//a') # => [<a level='1'> ... </>, <a level='2'/>]

引数なしでメソッド  REXML::Element#get_text を使うと、最初の子の最初のテキストノードを取得します。

  my_doc = Document.new "<p>some text <b>this is bold!</b> more text</p>"
  text_node = my_doc.root.get_text
  text_node.class # => REXML::Text
  text_node.to_s  # => "some text "

同じメソッドを引数+xpath+付きで使うと、xpathに照合する最初の子にある最初のテキストを取得します。

  my_doc.root.get_text(1) # => "this is bold!"

メソッド REXML::Element#text を引数なしで使うと、最初の子の最初のテキストノードからテキストを取得します。

  my_doc = Document.new "<p>some text <b>this is bold!</b> more text</p>"
  text_node = my_doc.root.text
  text_node.class # => String
  text_node       # => "some text "

同じメソッドを引数+xpath+付きで使うと、xpathに照合する最初の子の最初のテキストノードからテキストを取得します。

  my_doc.root.text(1) # => "this is bold!"

インクルードされたメソッド REXML::Node#find_first_recursive
を使うと、与えられたブロックが真値を返すようなものがあれば最初の子孫の要素を取得します。
もし何も無ければ+nil+を返します。

  doc.root.find_first_recursive do |ele|
    ele.name == 'price'
  end # => <price> ... </>
  doc.root.find_first_recursive do |ele|
    ele.name == 'nosuch'
  end # => nil

== 編集

=== 文書を編集する

[文書を作成する]

  REXML::Document::new メソッドで新しい文書を作成します。

    doc = Document.new(source_string)
    empty_doc = REXML::Document.new

[文書に追加する]

  メソッド REXML::Document#add と型が REXML::XMLDecl の引数でXML宣言を追加します。

    my_doc = Document.new
    my_doc.xml_decl.to_s # => ""
    my_doc.add(XMLDecl.new('2.0'))
    my_doc.xml_decl.to_s # => "<?xml version='2.0'?>"

  メソッド REXML::Document#add と型が REXML::DocType の引数で文書種別を追加します。

    my_doc = Document.new
    my_doc.doctype.to_s # => ""
    my_doc.add(DocType.new('foo'))
    my_doc.doctype.to_s # => "<!DOCTYPE foo>"

  REXML::Document#add と型が REXML::XMLDecl でも REXML::DocType でもない引数でその他のREXMLの型のノードを追加します。

    my_doc = Document.new
    my_doc.add(Element.new('foo'))
    my_doc.to_s # => "<foo/>"

  メソッド REXML::Document#add_element で既存の要素をルート要素として追加します。

    ele = Element.new('foo')
    my_doc = Document.new
    my_doc.add_element(ele)
    my_doc.root # => <foo/>

  メソッド REXML::Document#add_element で要素をルート要素として作成し追加します。

    my_doc = Document.new
    my_doc.add_element('foo')
    my_doc.root # => <foo/>

=== 要素を編集する

==== 要素を作成する

メソッド REXML::Element::new で新しい要素を作成します。

  ele = Element.new('foo') # => <foo/>

==== 要素のプロパティを設定する

メソッド REXML::Element#context= で要素に文脈を設定します（{要素の文脈}[../context_rdoc.html]を参照）。

  ele.context # => nil
  ele.context = {ignore_whitespace_nodes: :all}
  ele.context # => {:ignore_whitespace_nodes=>:all}

継承されたメソッド REXML::Child#parent= で要素の親を設定します。

  ele.parent # => nil
  ele.parent = Element.new('bar')
  ele.parent # => <bar/>

メソッド REXML::Element#text= で要素にテキストを設定します。

  ele.text # => nil
  ele.text = 'bar'
  ele.text # => "bar"

==== 要素に追加する

継承されたメソッド REXML::Parent#add （または別称の #push ）で最後の子としてノードを追加します。

  ele = Element.new('foo') # => <foo/>
  ele.push(Text.new('bar'))
  ele.push(Element.new('baz'))
  ele.children # => ["bar", <baz/>]

継承されたメソッド REXML::Parent#unshift で最初の子としてノードを追加します。

  ele = Element.new('foo') # => <foo/>
  ele.unshift(Element.new('bar'))
  ele.unshift(Text.new('baz'))
  ele.children # => ["bar", <baz/>]

メソッド REXML::Element#add_element で最後の子として要素を追加します。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_element(Element.new('baz'))
  ele.children # => [<bar/>, <baz/>]

メソッド REXML::Element#add_text で最後の子としてテキストノードを追加します。

  ele = Element.new('foo') # => <foo/>
  ele.add_text('bar')
  ele.add_text(Text.new('baz'))
  ele.children # => ["bar", "baz"]

メソッド REXML::Parent#insert_before で与えられたノードの前にノードを挿入します。

  ele = Element.new('foo') # => <foo/>
  ele.add_text('bar')
  ele.add_text(Text.new('baz'))
  ele.children    # => ["bar", "baz"]
  target = ele[1] # => "baz"
  ele.insert_before(target, Text.new('bat'))
  ele.children    # => ["bar", "bat", "baz"]

メソッド REXML::Parent#insert_after で与えられたノードの後にノードを挿入します。

  ele = Element.new('foo') # => <foo/>
  ele.add_text('bar')
  ele.add_text(Text.new('baz'))
  ele.children    # => ["bar", "baz"]
  target = ele[0] # => "bar"
  ele.insert_after(target, Text.new('bat'))
  ele.children    # => ["bar", "bat", "baz"]

メソッド REXML::Element#add_attribute で属性を追加します。

  ele = Element.new('foo') # => <foo/>
  ele.add_attribute('bar', 'baz')
  ele.add_attribute(Attribute.new('bat', 'bam'))
  ele.attributes # => {"bar"=>bar='baz', "bat"=>bat='bam'}

メソッド REXML::Element#add_attributes で複数の属性を追加します。

  ele = Element.new('foo') # => <foo/>
  ele.add_attributes({'bar' => 'baz', 'bat' => 'bam'})
  ele.add_attributes([['ban', 'bap'], ['bah', 'bad']])
  ele.attributes # => {"bar"=>bar='baz', "bat"=>bat='bam', "ban"=>ban='bap', "bah"=>bah='bad'}

メソッド REXML::Element#add_namespace で名前空間を追加します。

  ele = Element.new('foo') # => <foo/>
  ele.add_namespace('bar')
  ele.add_namespace('baz', 'bat')
  ele.namespaces # => {"xmlns"=>"bar", "baz"=>"bat"}

==== 要素から削除する

継承されたメソッド REXML::Parent#delete で特定の子オブジェクトを削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.children             # => [<bar/>, "baz"]
  target = ele[1]          # => "baz"
  ele.delete(target)       # => "baz"
  ele.children             # => [<bar/>]
  target = ele[0]          # => <baz/>
  ele.delete(target)       # => <baz/>
  ele.children             # => []

継承されたメソッド REXML::Parent#delete_at で特定のインデックスにある子を削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.children             # => [<bar/>, "baz"]
  ele.delete_at(1)
  ele.children             # => [<bar/>]
  ele.delete_at(0)
  ele.children             # => []

継承されたメソッド REXML::Parent#delete_if で特定の条件に合う全ての子を削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children             # => [<bar/>, "baz", <bat/>, "bam"]
  ele.delete_if {|child| child.instance_of?(Text) }
  ele.children # => [<bar/>, <bat/>]

メソッド REXML::Element#delete_element で1起点で指定されたインデックスにある要素を削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children             # => [<bar/>, "baz", <bat/>, "bam"]
  ele.delete_element(2)    # => <bat/>
  ele.children             # => [<bar/>, "baz", "bam"]
  ele.delete_element(1)    # => <bar/>
  ele.children             # => ["baz", "bam"]

同じメソッドで指定された要素を削除します。

  ele = Element.new('foo')   # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children               # => [<bar/>, "baz", <bat/>, "bam"]
  target = ele.elements[2]   # => <bat/>
  ele.delete_element(target) # => <bat/>
  ele.children               # => [<bar/>, "baz", "bam"]

同じメソッドを使ってxpathに照合する要素を削除します。

  ele = Element.new('foo')    # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children                # => [<bar/>, "baz", <bat/>, "bam"]
  ele.delete_element('./bat') # => <bat/>
  ele.children                # => [<bar/>, "baz", "bam"]
  ele.delete_element('./bar') # => <bar/>
  ele.children                # => ["baz", "bam"]

メソッド REXML::Element#delete_attribute で名前により属性を削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_attributes({'bar' => 'baz', 'bam' => 'bat'})
  ele.attributes           # => {"bar"=>bar='baz', "bam"=>bam='bat'}
  ele.delete_attribute('bam')
  ele.attributes           # => {"bar"=>bar='baz'}

メソッド REXML::Element#delete_namespace で名前空間を削除します。

  ele = Element.new('foo') # => <foo/>
  ele.add_namespace('bar')
  ele.add_namespace('baz', 'bat')
  ele.namespaces           # => {"xmlns"=>"bar", "baz"=>"bat"}
  ele.delete_namespace('xmlns')
  ele.namespaces           # => {} # => {"baz"=>"bat"}
  ele.delete_namespace('baz')
  ele.namespaces # => {}   # => {}

継承されたメソッド REXML::Child#remove で親から要素を削除します。

  ele = Element.new('foo')    # => <foo/>
  parent = Element.new('bar') # => <bar/>
  parent.add_element(ele)     # => <foo/>
  parent.children.size        # => 1
  ele.remove                  # => <foo/>
  parent.children.size        # => 0

==== ノードを入れ替える

継承されたメソッド REXML::Parent#[]= で、与えられた0起点のインデックスにあるノードを入れ替えます。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children             # => [<bar/>, "baz", <bat/>, "bam"]
  ele[2] = Text.new('bad') # => "bad"
  ele.children             # => [<bar/>, "baz", "bad", "bam"]

継承されたメソッド REXML::Parent#replace_child で、与えられたノードを他のノードで入れ替えます。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children             # => [<bar/>, "baz", <bat/>, "bam"]
  target = ele[2]          # => <bat/>
  ele.replace_child(target, Text.new('bah'))
  ele.children             # => [<bar/>, "baz", "bah", "bam"]

継承されたメソッド REXML::Child#replace_with で与えられたノードで +self+ を入れ替えます。

  ele = Element.new('foo') # => <foo/>
  ele.add_element('bar')
  ele.add_text('baz')
  ele.add_element('bat')
  ele.add_text('bam')
  ele.children             # => [<bar/>, "baz", <bat/>, "bam"]
  target = ele[2]          # => <bat/>
  target.replace_with(Text.new('bah'))
  ele.children             # => [<bar/>, "baz", "bah", "bam"]

=== クローン

メソッド REXML::Element#clone で浅いクローンを作成します。
クローンには名前と属性が含まれますが、親と子は含まれません。

  ele = Element.new('foo')
  ele.add_attributes({'bar' => 0, 'baz' => 1})
  ele.clone # => <foo bar='0' baz='1'/>

メソッド REXML::Document#clone で文書の浅いクローンを作成します。
XML宣言はコピーされます。
文書種別と根要素はクローンされません。

  my_xml = '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo><root/>'
  my_doc = Document.new(my_xml)
  clone_doc = my_doc.clone

  my_doc.xml_decl         # => <?xml ... ?>
  clone_doc.xml_decl      # => <?xml ... ?>

  my_doc.doctype.to_s     # => "<?xml version='1.0' encoding='UTF-8'?>"
  clone_doc.doctype.to_s  # => ""

  my_doc.root             # => <root/>
  clone_doc.root          # => nil

継承されたメソッド REXML::Parent#deep_clone で要素の深いクローンを作成します。
全てのノードと属性がコピーされます。

  doc.to_s.size   # => 825
  clone  = doc.deep_clone
  clone.to_s.size # => 825

== 文書を書き出す

メソッド REXML::Document#write で文書と\IOストリーム（既定では<tt>$stdout</tt>）に書き出します。

  doc.write

出力：

  <?xml version='1.0' encoding='UTF-8'?>
  <bookstore>

  <book category='cooking'>
    <title lang='en'>Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>

  <book category='children'>
    <title lang='en'>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>

  <book category='web'>
    <title lang='en'>XQuery Kick Start</title>
    <author>James McGovern</author>
    <author>Per Bothner</author>
    <author>Kurt Cagle</author>
    <author>James Linn</author>
    <author>Vaidyanathan Nagarajan</author>
    <year>2003</year>
    <price>49.99</price>
  </book>

  <book category='web' cover='paperback'>
    <title lang='en'>Learning XML</title>
    <author>Erik T. Ray</author>
    <year>2003</year>
    <price>39.95</price>
  </book>

  </bookstore>
