#
#       *****************************************************
#       *           GENERATED FILE, DO NOT EDIT             *
#       * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
#       *****************************************************
#
# This file was generated by po4a-translate(1). Do not store it (in VCS,
# for example), but store the PO file used as source file by po4a-translate.
#
# In fact, consider this as a binary, and the PO file as a regular source file:
# If the PO gets lost, keeping this translation up-to-date will be harder.
#
== [要素の文脈]

注意：ここにある全てのコードでは以下が実行されていることを前提にしています。

    require 'rexml/document'

- 便宜上、本ページの例では +REXML::Element.new+ ではなく +REXML::Document.new+ を使っています。
  これは完全に妥当です。
  なぜなら REXML::Document は REXML::Element の副クラスだからです。

要素の文脈は処理指示のハッシュで、\XMLが読まれたり、格納されたり、書き出されたりするやり方に影響します。
文脈の各項目は以下の通り。

- +:respect_whitespace+: 空白の扱いを制御します。
- +:compress_whitespace+: 空白が圧縮されるかを決定します。
- +:ignore_whitespace_nodes+: 空白のみのノードが無視されるかどうかを決定します。
- +:raw+: 特殊な文字と実体の扱いを制御します。

新しい要素の既定の文脈は<tt>{}</tt>です。
文脈は要素の作成時に設定できます。

  d = REXML::Document.new('', {compress_whitespace: :all, raw: :all})
  d.context # => {:compress_whitespace=>:all, :raw=>:all}

新しいハッシュを代入することで文脈全体を白紙に戻せます。

  d.context = {ignore_whitespace_nodes: :all}
  d.context # => {:ignore_whitespace_nodes=>:all}

もしくは個別の項目を作成したり変更したりできます。

  d.context[:raw] = :all
  d.context # => {:ignore_whitespace_nodes=>:all, :raw=>:all}

=== +:respect_whitespace+

影響があるもの：+REXML::Element.new+, +REXML::Element.text=+

既定では全ての解析された空白が保たれます（つまり、保管された空白は圧縮されません）。

  xml_string = '<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>'
  d = REXML::Document.new(xml_string)
  d.to_s # => "<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>"

要素名の配列と共に +:respect_whitespace+ を使うと、 _厳密に_ 空白が保たれる要素を指定します。
他の要素の空白や要素間の空白は圧縮されます。

この例では+foo+と+baz+は空白が保たれる名前空間を持ちます。
+ baz+と要素間の空白は、圧縮される名前空間を持ちます。

  d = REXML::Document.new(xml_string, {respect_whitespace: ['foo', 'baz']})
  d.to_s # => "<root><foo>a   b</foo> <bar>c d</bar> <baz>e   f</baz></root>"
  bar = d.root[2] # => <bar> ... </>
  bar.text = 'X   Y'
  d.to_s # => "<root><foo>a   b</foo> <bar>X Y</bar> <baz>e   f</baz></root>"

=== +:compress_whitespace+

影響があるもの：+REXML::Element.new+, +REXML::Element.text=+

<tt>compress_whitespace: :all</tt>を使うと要素の中と要素間の両方で空白を圧縮します。

  xml_string = '<root><foo>a   b</foo>    <bar>c   d</bar>   <baz>e   f</baz></root>'
  d = REXML::Document.new(xml_string, {compress_whitespace: :all})
  d.to_s # => "<root><foo>a b</foo> <bar>c d</bar> <baz>e f</baz></root>"

要素名の配列と一緒に +:compress_whitespace+
を使うと、それらの要素の空白が圧縮されますが、他の要素の中や他の要素間では圧縮されません。

この例では+foo+と+baz+は空白が圧縮されます。
+ bar+と要素間の空白は圧縮されません。

  d = REXML::Document.new(xml_string, {compress_whitespace: ['foo', 'baz']})
  d.to_s # => "<root><foo>a b</foo>    <bar>c   d</bar>   <baz>e f</baz></root>"
  foo = d.root[0] # => <foo> ... </>
  foo.text= 'X   Y'
  d.to_s # => "<root><foo>X Y</foo>    <bar>c   d</bar>   <baz>e f</baz></root>"

=== +:ignore_whitespace_nodes+

影響があるもの：+REXML::Element.new+

<tt>ignore_whitespace_nodes: :all</tt>を使うと全ての空白のみの要素が省かれます。

この例では+bar+にテキストノードがありますが、ノード+foo+および+bar+にはありません。

  xml_string = '<root><foo>   </foo><bar> BAR </bar><baz>   </baz></root>'
  d = REXML::Document.new(xml_string, {ignore_whitespace_nodes: :all})
  d.to_s # => "<root><foo> FOO </foo><bar/><baz> BAZ </baz></root>"
  root = d.root   # => <root> ... </>
  foo = root[0]   # => <foo/>
  bar = root[1]   # => <bar> ... </>
  baz = root[2]   # => <baz/>
  foo.first.class # => NilClass
  bar.first.class # => REXML::Text
  baz.first.class # => NilClass

+:ignore_whitespace_nodes+を要素名の配列と共に使うと、空白ノードが無視される要素が指定されます。

この例では+bar+と+baz+にテキストノードがあります。
一方で+foo+にはありません。

  xml_string = '<root><foo>   </foo><bar> BAR </bar><baz>   </baz></root>'
  d = REXML::Document.new(xml_string, {ignore_whitespace_nodes: ['foo']})
  d.to_s # => "<root><foo/><bar> BAR </bar><baz>   </baz></root>"
  root = d.root   # => <root> ... </>
  foo = root[0]   # => <foo/>
  bar = root[1]   # => <bar> ... </>
  baz = root[2]   # => <baz> ... </>
  foo.first.class # => NilClass
  bar.first.class # => REXML::Text
  baz.first.class # => REXML::Text

=== +:raw+

影響するもの：+Element.text=+, +Element.add_text+, +Text.to_s+

+a+要素の解析は+raw+の影響を受けません。

  xml_string = '<root><a>0 &lt; 1</a><b>1 &gt; 0</b></root>'
  d = REXML::Document.new(xml_string, {:raw => ['a']})
  d.root.to_s # => "<root><a>0 &lt; 1</a><b>1 &gt; 0</b></root>"
  a, b = *d.root.elements
  a.to_s # => "<a>0 &lt; 1</a>"
  b.to_s # => "<b>1 &gt; 0</b>"

しかし Element#text= は影響を受けます。

  a.text = '0 &lt; 1'
  b.text = '1 &gt; 0'
  a.to_s # => "<a>0 &lt; 1</a>"
  b.to_s # => "<b>1 &amp;gt; 0</b>"

Element.add_text も同様です。

  a.add_text(' so 1 &gt; 0')
  b.add_text(' so 0 &lt; 1')
  a.to_s # => "<a>0 &lt; 1 so 1 &gt; 0</a>"
  b.to_s # => "<b>1 &amp;gt; 0 so 0 &amp;lt; 1</b>"
